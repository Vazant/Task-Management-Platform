---
alwaysApply: true
---
# Java Spring Boot Architecture Rules

You are a senior Java architect and expert in building multi-layered REST services. These rules ensure consistency, maintainability, and adherence to Clean Architecture principles in Spring Boot applications.

## Общие принципы

### 1. Слоистая архитектура
```
Controller Layer (Presentation)
    ↓
Business Service Layer (Application)
    ↓
CRUD Service Layer (Infrastructure)
    ↓
Repository Layer (Data Access)
```

### 2. Принципы SOLID и Clean Architecture
- **Внешние слои зависят от внутренних**
- **Внутренние слои не знают о внешних**
- **Бизнес-логика изолирована от инфраструктуры**
- **Single Responsibility Principle** - каждый класс имеет одну ответственность
- **Dependency Inversion** - зависимости направлены к абстракциям

## Детальные требования

### 1. Контроллеры (Presentation Layer)

#### 1.1 Наследование от BaseController
- **Требование**: Наследуйтесь от BaseController только для простых CRUD операций без бизнес-логики
- **Обоснование**: Обеспечивает консистентность и переиспользование кода для стандартных операций
- **Пример правильного использования**:
```java
@Slf4j
@RestController
@RequestMapping("/api/categories")
public class CategoryController extends BaseController<Category> {

    private final CategoryService categoryService;

    public CategoryController(@Qualifier("categoryCrudService") CrudService<Category> categoryService) {
        super(categoryService);
        this.categoryService = (CategoryService) categoryService;
    }

    // Только кастомные операции, базовые CRUD наследуются
    @GetMapping("/active")
    public ResponseEntity<List<Category>> getActiveCategories() {
        return ResponseEntity.ok(categoryService.findActiveCategories());
    }
}
```

#### 1.2 Структура сложного контроллера
- **Требование**: Для сложной бизнес-логики создавайте отдельный контроллер без наследования
- **Обоснование**: Позволяет полный контроль над API и бизнес-операциями
- **Пример правильного использования**:
```java
@Slf4j
@RestController
@RequestMapping("/api/orders")
public class OrderController {

    private final OrderBusinessService orderBusinessService;
    private final OrderService orderService;
    private final OrganizationRepository organizationRepository;

    public OrderController(
            @Qualifier("orderCrudService") CrudService<Order> orderCrudService,
            OrderService orderService,
            OrderBusinessService orderBusinessService,
            OrganizationRepository organizationRepository) {
        this.orderBusinessService = orderBusinessService;
        this.orderService = orderService;
        this.organizationRepository = organizationRepository;
    }

    // Бизнес-операции
    @PostMapping
    public ResponseEntity<Order> createOrder(@Valid @RequestBody OrderRequest request) {
        Organization organization = getCurrentOrganization();
        Order order = orderBusinessService.createOrder(request, organization);
        return ResponseEntity.ok(order);
    }

    // CRUD операции (дублируем из BaseController)
    @GetMapping
    public ResponseEntity<List<Order>> getAll() {
        return ResponseEntity.ok(orderService.findAll());
    }

    @GetMapping("/{uuid}")
    public ResponseEntity<Order> getById(@PathVariable @ValidUuid String uuid) {
        return ResponseEntity.ok(orderService.findByUuid(uuid));
    }

    // Кастомные операции
    @PutMapping("/{uuid}/status")
    public ResponseEntity<Order> updateStatus(
            @PathVariable @ValidUuid String uuid, 
            @RequestParam OrderStatus status) {
        Order order = orderBusinessService.updateStatus(uuid, status);
        return ResponseEntity.ok(order);
    }

    @GetMapping("/customer/{customerId}")
    public ResponseEntity<List<Order>> findByCustomer(@PathVariable @ValidUuid String customerId) {
        List<Order> orders = orderBusinessService.findByCustomer(customerId);
        return ResponseEntity.ok(orders);
    }
}
```

#### 1.3 REST Endpoints и HTTP методы
- **Требование**: Используйте правильные HTTP методы и статус коды
- **Обоснование**: Обеспечивает RESTful API и правильную семантику
- **Пример правильного использования**:
```java
@RestController
@RequestMapping("/api/products")
public class ProductController extends BaseController<Product> {

    // GET - получение данных
    @GetMapping("/{uuid}")
    public ResponseEntity<Product> getById(@PathVariable @ValidUuid String uuid) {
        return ResponseEntity.ok(productService.findByUuid(uuid));
    }

    // POST - создание нового ресурса
    @PostMapping
    public ResponseEntity<Product> create(@Valid @RequestBody Product product) {
        Product created = productService.create(product);
        return ResponseEntity.status(HttpStatus.CREATED).body(created);
    }

    // PUT - полное обновление ресурса
    @PutMapping("/{uuid}")
    public ResponseEntity<Product> update(@PathVariable @ValidUuid String uuid, 
                                        @Valid @RequestBody Product product) {
        Product updated = productService.update(uuid, product);
        return ResponseEntity.ok(updated);
    }

    // PATCH - частичное обновление
    @PatchMapping("/{uuid}/stock")
    public ResponseEntity<Product> updateStock(@PathVariable @ValidUuid String uuid,
                                             @RequestParam int newStock) {
        Product updated = productService.updateStock(uuid, newStock);
        return ResponseEntity.ok(updated);
    }

    // DELETE - удаление ресурса
    @DeleteMapping("/{uuid}")
    public ResponseEntity<Void> delete(@PathVariable @ValidUuid String uuid) {
        productService.delete(uuid);
        return ResponseEntity.noContent().build();
    }
}
```

### 2. Сервисы (Application Layer)

#### 2.1 Иерархия сервисов
- **Требование**: Следуйте иерархии CrudService → AbstractCrudService → EntityService → EntityBusinessService
- **Обоснование**: Обеспечивает разделение ответственности и переиспользование кода
- **Пример правильного использования**:
```java
// 1. CrudService Interface
public interface CrudService<T extends BaseEntity & Updatable<T>> {
    T findByUuid(String uuidStr);
    List<T> findAll();
    T create(T entity);
    T update(String uuidStr, T updatedEntity);
    void delete(String uuidStr);
    boolean exists(String uuidStr);
    long count();
}

// 2. AbstractCrudService
@Slf4j
@RequiredArgsConstructor
public abstract class AbstractCrudService<T extends BaseEntity & Updatable<T>> 
    implements CrudService<T> {

    private final JpaRepository<T, UUID> repository;
    private final Class<T> entityClass;

    @Override
    public T findByUuid(String uuidStr) {
        UUID uuid = UuidUtils.parse(uuidStr);
        return repository.findByUuid(uuid)
            .orElseThrow(() -> new EntityNotFoundException(
                String.format("%s not found: %s", getEntityName(), uuidStr)));
    }

    @Override
    @Transactional
    public T create(T entity) {
        log.info("Creating {}: {}", getEntityName(), entity);
        return repository.save(entity);
    }

    @Override
    @Transactional
    public T update(String uuidStr, T updatedEntity) {
        T existing = findByUuid(uuidStr);
        existing.updateFrom(updatedEntity);
        existing.setUpdatedAt(LocalDateTime.now());
        return repository.save(existing);
    }

    protected abstract String getEntityName();
}

// 3. EntityService (наследует AbstractCrudService)
@Slf4j
@Service("productCrudService")
@Transactional
public class ProductService extends AbstractCrudService<Product> {

    private final ProductRepository productRepository;

    public ProductService(ProductRepository productRepository) {
        super(productRepository, Product.class);
        this.productRepository = productRepository;
    }

    @Override
    protected String getEntityName() {
        return Constants.ENTITY_PRODUCT;
    }

    // Дополнительные методы поиска
    public List<Product> findByCategory(String categoryId) {
        return productRepository.findByCategoryUuid(UuidUtils.parse(categoryId));
    }

    public List<Product> findByNameContaining(String name) {
        return productRepository.findByNameContainingIgnoreCase(name);
    }
}

// 4. EntityBusinessService (бизнес-логика)
@Slf4j
@Service
@Transactional
@RequiredArgsConstructor
public class ProductBusinessService implements CrudService<Product> {

    private final ProductService productService;
    private final ProductCreationService creationService;
    private final CategoryRepository categoryRepository;

    // Реализация CrudService методов
    @Override
    public Product findByUuid(String uuidStr) {
        return productService.findByUuid(uuidStr);
    }

    @Override
    public List<Product> findAll() {
        return productService.findAll();
    }

    // Бизнес-методы
    public Product createProduct(ProductRequest request, Organization organization) {
        log.info("Creating product from request: {}", request);
        
        // Валидация
        validateRequest(request);
        
        // Создание через специализированный сервис
        Product product = creationService.createProduct(request, organization);
        
        // Сохранение
        Product saved = productService.create(product);
        
        // Публикация событий
        publishProductCreatedEvent(saved);
        
        return saved;
    }

    public Product updateStock(String productId, int newStock) {
        Product product = findByUuid(productId);
        product.setStockQuantity(newStock);
        product.setUpdatedAt(LocalDateTime.now());
        
        Product updated = productService.update(productId, product);
        
        // Публикация события
        publishStockUpdatedEvent(updated);
        
        return updated;
    }

    private void validateRequest(ProductRequest request) {
        // Валидация бизнес-правил
        if (request.stockQuantity() < 0) {
            throw new BusinessRuleViolationException("Stock quantity cannot be negative");
        }
    }

    private void publishProductCreatedEvent(Product product) {
        // Публикация доменного события
    }

    private void publishStockUpdatedEvent(Product product) {
        // Публикация доменного события
    }
}
```

#### 2.2 Специализированные сервисы создания
- **Требование**: Создавайте отдельные сервисы для сложной логики создания сущностей
- **Обоснование**: Разделяет ответственность и упрощает тестирование
- **Пример правильного использования**:
```java
@Service
@RequiredArgsConstructor
public class ProductCreationService {

    private final CategoryRepository categoryRepository;
    private final OrganizationRepository organizationRepository;

    public Product createProduct(ProductRequest request, Organization organization) {
        // Валидация зависимостей
        Category category = validateCategory(request.categoryId());
        
        // Создание сущности
        Product product = ProductBuilder.product()
            .name(request.name())
            .description(request.description())
            .skuCode(request.skuCode())
            .dimensions(request.dimensions())
            .stockQuantity(request.stockQuantity())
            .categoryId(category.getUuid())
            .organization(organization)
            .build();
        
        // Создание связанных сущностей
        List<ProductPrice> prices = createPrices(request.prices(), product);
        product.setPrices(prices);
        
        return product;
    }

    private Category validateCategory(String categoryId) {
        return categoryRepository.findByUuid(UuidUtils.parse(categoryId))
            .orElseThrow(() -> new IllegalArgumentException("Category not found: " + categoryId));
    }

    private List<ProductPrice> createPrices(List<PriceRequest> priceRequests, Product product) {
        return priceRequests.stream()
            .map(priceRequest -> createPrice(priceRequest, product))
            .collect(Collectors.toList());
    }

    private ProductPrice createPrice(PriceRequest priceRequest, Product product) {
        return ProductPriceBuilder.productPrice()
            .product(product)
            .price(MoneyBuilder.money()
                .amount(priceRequest.amount())
                .currency(priceRequest.currency())
                .build())
            .build();
    }
}
```

### 3. DTO и Валидация

#### 3.1 Request DTO объекты
- **Требование**: Используйте @JiltBuilder и Bean Validation для всех DTO
- **Обоснование**: Обеспечивает иммутабельность, валидацию и удобство создания
- **Пример правильного использования**:
```java
@JiltBuilder
public record ProductRequest(
    @NotBlank(message = "Product name is required")
    @Size(min = 2, max = 100, message = "Product name must be between 2 and 100 characters")
    String name,
    
    @Size(max = 1000, message = "Description cannot exceed 1000 characters")
    String description,
    
    @NotBlank(message = "SKU code is required")
    @Pattern(regexp = "^[A-Z0-9-]+$", message = "SKU code must contain only uppercase letters, numbers and hyphens")
    String skuCode,
    
    @Valid
    DimensionsRequest dimensions,
    
    @Min(value = 0, message = "Stock quantity cannot be negative")
    int stockQuantity,
    
    @NotNull(message = "Category ID is required")
    @ValidUuid
    String categoryId,
    
    @Valid
    List<PriceRequest> prices) {}
```

#### 3.2 Response DTO объекты
- **Требование**: Создавайте отдельные Response DTO для сложных ответов
- **Обоснование**: Контролирует данные, отправляемые клиенту, и улучшает производительность
- **Пример правильного использования**:
```java
@JiltBuilder
public record ProductResponse(
    String uuid,
    String name,
    String description,
    String skuCode,
    DimensionsResponse dimensions,
    int stockQuantity,
    String categoryName,
    List<PriceResponse> prices,
    LocalDateTime createdAt,
    LocalDateTime updatedAt) {}

@JiltBuilder
public record ProductListResponse(
    List<ProductSummaryResponse> products,
    int totalCount,
    int pageNumber,
    int pageSize) {}

@JiltBuilder
public record ProductSummaryResponse(
    String uuid,
    String name,
    String skuCode,
    MoneyResponse lowestPrice,
    int stockQuantity) {}
```

#### 3.3 Кастомная валидация
- **Требование**: Создавайте отдельные валидаторы для сложной бизнес-логики
- **Обоснование**: Разделяет валидацию и упрощает тестирование
- **Пример правильного использования**:
```java
@Component
public class ProductRequestValidator {

    private final CategoryRepository categoryRepository;
    private final ProductRepository productRepository;

    public void validate(ProductRequest request) {
        // Валидация бизнес-правил
        validateCategoryExists(request.categoryId());
        validateSkuCodeUnique(request.skuCode());
        validatePrices(request.prices());
        validateStockQuantity(request.stockQuantity());
    }

    private void validateCategoryExists(String categoryId) {
        if (!categoryRepository.existsByUuid(UuidUtils.parse(categoryId))) {
            throw new EntityValidationException("Category not found: " + categoryId);
        }
    }

    private void validateSkuCodeUnique(String skuCode) {
        if (productRepository.existsBySkuCode(skuCode)) {
            throw new EntityValidationException("SKU code already exists: " + skuCode);
        }
    }

    private void validatePrices(List<PriceRequest> prices) {
        if (prices == null || prices.isEmpty()) {
            throw new EntityValidationException("At least one price is required");
        }
        
        // Проверка уникальности валют
        Set<Currency> currencies = prices.stream()
            .map(PriceRequest::currency)
            .collect(Collectors.toSet());
        
        if (currencies.size() != prices.size()) {
            throw new EntityValidationException("Duplicate currencies are not allowed");
        }
    }

    private void validateStockQuantity(int stockQuantity) {
        if (stockQuantity < 0) {
            throw new EntityValidationException("Stock quantity cannot be negative");
        }
    }
}
```

### 4. Обработка ошибок

#### 4.1 Иерархия исключений
- **Требование**: Создавайте иерархию исключений для разных типов ошибок
- **Обоснование**: Обеспечивает правильную обработку и логирование ошибок
- **Пример правильного использования**:
```java
// Базовое исключение для домена
public abstract class DomainException extends RuntimeException {
    public DomainException(String message) {
        super(message);
    }
    
    public DomainException(String message, Throwable cause) {
        super(message, cause);
    }
}

// Специфичные исключения
public class EntityNotFoundException extends DomainException {
    public EntityNotFoundException(String message) {
        super(message);
    }
}

public class EntityValidationException extends DomainException {
    public EntityValidationException(String message) {
        super(message);
    }
}

public class BusinessRuleViolationException extends DomainException {
    public BusinessRuleViolationException(String message) {
        super(message);
    }
}

public class DuplicateEntityException extends DomainException {
    public DuplicateEntityException(String message) {
        super(message);
    }
}
```

#### 4.2 Глобальная обработка исключений
- **Требование**: Создавайте @ControllerAdvice для централизованной обработки ошибок
- **Обоснование**: Обеспечивает консистентные ответы API и правильные HTTP статусы
- **Пример правильного использования**:
```java
@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(EntityNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleEntityNotFound(EntityNotFoundException ex, 
                                                             HttpServletRequest request) {
        log.warn("Entity not found: {}", ex.getMessage());
        
        ErrorResponse error = ErrorResponse.builder()
            .timestamp(LocalDateTime.now())
            .status(HttpStatus.NOT_FOUND.value())
            .error("NOT_FOUND")
            .message(ex.getMessage())
            .path(request.getRequestURI())
            .build();
        
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);
    }

    @ExceptionHandler(EntityValidationException.class)
    public ResponseEntity<ErrorResponse> handleValidation(EntityValidationException ex, 
                                                         HttpServletRequest request) {
        log.warn("Validation error: {}", ex.getMessage());
        
        ErrorResponse error = ErrorResponse.builder()
            .timestamp(LocalDateTime.now())
            .status(HttpStatus.BAD_REQUEST.value())
            .error("VALIDATION_ERROR")
            .message(ex.getMessage())
            .path(request.getRequestURI())
            .build();
        
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(error);
    }

    @ExceptionHandler(BusinessRuleViolationException.class)
    public ResponseEntity<ErrorResponse> handleBusinessRule(BusinessRuleViolationException ex, 
                                                           HttpServletRequest request) {
        log.warn("Business rule violation: {}", ex.getMessage());
        
        ErrorResponse error = ErrorResponse.builder()
            .timestamp(LocalDateTime.now())
            .status(HttpStatus.CONFLICT.value())
            .error("BUSINESS_RULE_VIOLATION")
            .message(ex.getMessage())
            .path(request.getRequestURI())
            .build();
        
        return ResponseEntity.status(HttpStatus.CONFLICT).body(error);
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ValidationErrorResponse> handleValidationErrors(
            MethodArgumentNotValidException ex, HttpServletRequest request) {
        
        List<ValidationErrorResponse.FieldError> fieldErrors = ex.getBindingResult()
            .getFieldErrors()
            .stream()
            .map(this::createFieldError)
            .collect(Collectors.toList());
        
        ValidationErrorResponse error = ValidationErrorResponse.builder()
            .timestamp(LocalDateTime.now())
            .status(HttpStatus.BAD_REQUEST.value())
            .error("VALIDATION_ERROR")
            .message("Validation failed")
            .path(request.getRequestURI())
            .fieldErrors(fieldErrors)
            .build();
        
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(error);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGeneric(Exception ex, HttpServletRequest request) {
        log.error("Unexpected error occurred: {}", ex.getMessage(), ex);
        
        ErrorResponse error = ErrorResponse.builder()
            .timestamp(LocalDateTime.now())
            .status(HttpStatus.INTERNAL_SERVER_ERROR.value())
            .error("INTERNAL_SERVER_ERROR")
            .message("An unexpected error occurred")
            .path(request.getRequestURI())
            .build();
        
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }

    private ValidationErrorResponse.FieldError createFieldError(FieldError fieldError) {
        return ValidationErrorResponse.FieldError.builder()
            .field(fieldError.getField())
            .message(fieldError.getDefaultMessage())
            .rejectedValue(fieldError.getRejectedValue())
            .build();
    }
}
```

## Примеры использования

### Пример 1: Полный CRUD контроллер с бизнес-логикой
```java
@Slf4j
@RestController
@RequestMapping("/api/orders")
public class OrderController {

    private final OrderBusinessService orderBusinessService;
    private final OrderService orderService;
    private final OrganizationRepository organizationRepository;

    public OrderController(
            @Qualifier("orderCrudService") CrudService<Order> orderCrudService,
            OrderService orderService,
            OrderBusinessService orderBusinessService,
            OrganizationRepository organizationRepository) {
        this.orderBusinessService = orderBusinessService;
        this.orderService = orderService;
        this.organizationRepository = organizationRepository;
    }

    // Бизнес-операции
    @PostMapping
    public ResponseEntity<Order> createOrder(@Valid @RequestBody OrderRequest request) {
        log.info("Creating order for customer: {}", request.customerUuid());
        
        Organization organization = getCurrentOrganization();
        Order order = orderBusinessService.createOrder(request, organization);
        
        log.info("Order created successfully: {}", order.getUuid());
        return ResponseEntity.status(HttpStatus.CREATED).body(order);
    }

    // CRUD операции
    @GetMapping
    public ResponseEntity<List<Order>> getAll() {
        return ResponseEntity.ok(orderService.findAll());
    }

    @GetMapping("/{uuid}")
    public ResponseEntity<Order> getById(@PathVariable @ValidUuid String uuid) {
        return ResponseEntity.ok(orderService.findByUuid(uuid));
    }

    @PutMapping("/{uuid}")
    public ResponseEntity<Order> update(@PathVariable @ValidUuid String uuid, 
                                      @Valid @RequestBody Order order) {
        Order updated = orderService.update(uuid, order);
        return ResponseEntity.ok(updated);
    }

    @DeleteMapping("/{uuid}")
    public ResponseEntity<Void> delete(@PathVariable @ValidUuid String uuid) {
        orderService.delete(uuid);
        return ResponseEntity.noContent().build();
    }

    // Кастомные операции
    @PutMapping("/{uuid}/status")
    public ResponseEntity<Order> updateStatus(
            @PathVariable @ValidUuid String uuid, 
            @RequestParam OrderStatus status) {
        log.info("Updating order status: {} -> {}", uuid, status);
        
        Order order = orderBusinessService.updateStatus(uuid, status);
        return ResponseEntity.ok(order);
    }

    @GetMapping("/customer/{customerId}")
    public ResponseEntity<List<Order>> findByCustomer(@PathVariable @ValidUuid String customerId) {
        List<Order> orders = orderBusinessService.findByCustomer(customerId);
        return ResponseEntity.ok(orders);
    }

    @GetMapping("/status/{status}")
    public ResponseEntity<List<Order>> findByStatus(@PathVariable OrderStatus status) {
        List<Order> orders = orderBusinessService.findByStatus(status);
        return ResponseEntity.ok(orders);
    }

    @GetMapping("/organization/{organizationId}")
    public ResponseEntity<List<Order>> findByOrganization(
            @PathVariable @ValidUuid String organizationId) {
        List<Order> orders = orderBusinessService.findByOrganization(organizationId);
        return ResponseEntity.ok(orders);
    }

    private Organization getCurrentOrganization() {
        // Получение текущей организации из контекста безопасности
        return organizationRepository.findByUuid(getCurrentOrganizationUuid())
            .orElseThrow(() -> new EntityNotFoundException("Current organization not found"));
    }

    private UUID getCurrentOrganizationUuid() {
        // Получение UUID организации из контекста безопасности
        return SecurityContextHolder.getContext().getAuthentication().getOrganizationUuid();
    }
}
```

### Пример 2: Бизнес-сервис с транзакциями и событиями
```java
@Slf4j
@Service
@Transactional
@RequiredArgsConstructor
public class OrderBusinessService implements CrudService<Order> {

    private final OrderService orderService;
    private final OrderCreationService creationService;
    private final CustomerRepository customerRepository;
    private final ProductRepository productRepository;
    private final DomainEventPublisher eventPublisher;

    // Реализация CrudService методов
    @Override
    public Order findByUuid(String uuidStr) {
        return orderService.findByUuid(uuidStr);
    }

    @Override
    public List<Order> findAll() {
        return orderService.findAll();
    }

    @Override
    public Order create(Order entity) {
        return orderService.create(entity);
    }

    @Override
    public Order update(String uuidStr, Order updatedEntity) {
        return orderService.update(uuidStr, updatedEntity);
    }

    @Override
    public void delete(String uuidStr) {
        orderService.delete(uuidStr);
    }

    @Override
    public boolean exists(String uuidStr) {
        return orderService.exists(uuidStr);
    }

    @Override
    public long count() {
        return orderService.count();
    }

    // Бизнес-методы
    public Order createOrder(OrderRequest request, Organization organization) {
        log.info("Creating order from request: customer={}, items={}", 
            request.customerUuid(), request.items().size());
        
        try {
            // Валидация
            validateOrderRequest(request);
            
            // Создание через специализированный сервис
            Order order = creationService.createOrder(request, organization);
            
            // Сохранение
            Order saved = create(order);
            
            // Публикация событий
            publishOrderCreatedEvent(saved);
            
            log.info("Order created successfully: uuid={}", saved.getUuid());
            return saved;
            
        } catch (Exception e) {
            log.error("Failed to create order: customer={}, error={}", 
                request.customerUuid(), e.getMessage(), e);
            throw e;
        }
    }

    public Order updateStatus(String orderId, OrderStatus status) {
        log.info("Updating order status: id={}, newStatus={}", orderId, status);
        
        Order order = findByUuid(orderId);
        OrderStatus oldStatus = order.getStatus();
        
        // Проверка возможности изменения статуса
        if (!oldStatus.canTransitionTo(status)) {
            throw new BusinessRuleViolationException(
                String.format("Cannot transition from %s to %s", oldStatus, status));
        }
        
        order.setStatus(status);
        order.setUpdatedAt(LocalDateTime.now());
        
        Order updated = update(orderId, order);
        
        // Публикация события
        publishOrderStatusChangedEvent(updated, oldStatus, status);
        
        log.info("Order status updated: id={}, oldStatus={}, newStatus={}", 
            orderId, oldStatus, status);
        
        return updated;
    }

    public List<Order> findByCustomer(String customerId) {
        return orderService.findByCustomer(customerId);
    }

    public List<Order> findByStatus(OrderStatus status) {
        return orderService.findByStatus(status);
    }

    public List<Order> findByOrganization(String organizationId) {
        return orderService.findByOrganization(organizationId);
    }

    // Приватные методы
    private void validateOrderRequest(OrderRequest request) {
        // Валидация клиента
        Customer customer = validateCustomer(request.customerUuid());
        
        // Валидация продуктов
        validateProducts(request.items());
        
        // Валидация общей суммы
        validateTotalAmount(request);
    }

    private Customer validateCustomer(String customerUuid) {
        return customerRepository.findByUuid(UuidUtils.parse(customerUuid))
            .orElseThrow(() -> new EntityNotFoundException("Customer not found: " + customerUuid));
    }

    private void validateProducts(List<OrderItemRequest> items) {
        items.forEach(item -> {
            Product product = productRepository.findByUuid(UuidUtils.parse(item.productUuid()))
                .orElseThrow(() -> new EntityNotFoundException("Product not found: " + item.productUuid()));
            
            if (product.getStockQuantity() < item.quantity()) {
                throw new BusinessRuleViolationException(
                    "Insufficient stock for product: " + item.productUuid());
            }
        });
    }

    private void validateTotalAmount(OrderRequest request) {
        BigDecimal calculatedTotal = request.items().stream()
            .map(item -> item.price().amount().multiply(BigDecimal.valueOf(item.quantity())))
            .reduce(BigDecimal.ZERO, BigDecimal::add);
        
        if (calculatedTotal.compareTo(request.total().amount()) != 0) {
            throw new EntityValidationException("Total amount does not match items total");
        }
    }

    private void publishOrderCreatedEvent(Order order) {
        OrderCreatedEvent event = new OrderCreatedEvent(order.getUuid(), order.getCustomer().getUuid());
        eventPublisher.publish(event);
    }

    private void publishOrderStatusChangedEvent(Order order, OrderStatus oldStatus, OrderStatus newStatus) {
        OrderStatusChangedEvent event = new OrderStatusChangedEvent(
            order.getUuid(), oldStatus, newStatus);
        eventPublisher.publish(event);
    }
}
```

## Анти-примеры (что НЕ делать)

### Анти-пример 1: Нарушение слоев архитектуры
```java
// ПЛОХО: Контроллер напрямую обращается к репозиторию
@RestController
@RequestMapping("/api/orders")
public class OrderController {

    @Autowired
    private OrderRepository orderRepository; // Нарушение слоев!

    @PostMapping
    public ResponseEntity<Order> createOrder(@RequestBody OrderRequest request) {
        // Бизнес-логика в контроллере - НЕПРАВИЛЬНО!
        Customer customer = customerRepository.findByUuid(request.customerUuid())
            .orElseThrow(() -> new RuntimeException("Customer not found"));
        
        Order order = new Order();
        order.setCustomer(customer);
        order.setTotal(request.total());
        // ... много бизнес-логики
        
        Order saved = orderRepository.save(order); // Прямой доступ к репозиторию
        return ResponseEntity.ok(saved);
    }
}
```
**Проблемы**:
- Нарушение принципа разделения ответственности
- Бизнес-логика в контроллере
- Прямой доступ к репозиторию из контроллера
- Сложность тестирования

### Анти-пример 2: Неправильная обработка ошибок
```java
// ПЛОХО: Неправильная обработка исключений
@RestController
@RequestMapping("/api/products")
public class ProductController {

    @PostMapping
    public ResponseEntity<Product> createProduct(@RequestBody ProductRequest request) {
        try {
            Product product = productService.createProduct(request);
            return ResponseEntity.ok(product);
        } catch (Exception e) {
            // Неправильно: возвращаем 500 для всех ошибок
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(null);
        }
    }

    @GetMapping("/{uuid}")
    public ResponseEntity<Product> getProduct(@PathVariable String uuid) {
        Product product = productService.findByUuid(uuid);
        if (product == null) {
            // Неправильно: возвращаем null вместо исключения
            return ResponseEntity.notFound().build();
        }
        return ResponseEntity.ok(product);
    }
}
```
**Проблемы**:
- Неправильные HTTP статусы
- Отсутствие детальной информации об ошибках
- Возврат null вместо исключений
- Отсутствие логирования ошибок

### Анти-пример 3: Неправильная структура DTO
```java
// ПЛОХО: Отсутствие валидации и неправильная структура
public class ProductRequest {
    public String name; // Нет валидации
    public String description;
    public BigDecimal price; // Нет валидации
    public String categoryId;
    
    // Нет конструктора, геттеров, сеттеров
    // Нет equals, hashCode, toString
}

// ПЛОХО: Возврат внутренних сущностей
@GetMapping("/{uuid}")
public ResponseEntity<Product> getProduct(@PathVariable String uuid) {
    Product product = productService.findByUuid(uuid);
    // Возвращаем внутреннюю сущность с лишними данными
    return ResponseEntity.ok(product);
}
```
**Проблемы**:
- Отсутствие валидации входных данных
- Возврат внутренних сущностей клиенту
- Нарушение инкапсуляции
- Потенциальные проблемы безопасности

## Часто задаваемые вопросы

### Вопрос 1: Когда наследоваться от BaseController?
**Ответ**: Наследуйтесь от BaseController только когда:
- У вас простые CRUD операции без сложной бизнес-логики
- Вы не нуждаетесь в специфичных DTO для операций
- У вас нет дополнительной валидации или трансформации данных
- Вы не интегрируетесь с внешними сервисами

Для сложной бизнес-логики создавайте отдельный контроллер без наследования.

### Вопрос 2: Как правильно структурировать сервисы?
**Ответ**: Следуйте иерархии:
1. **CrudService** - интерфейс с базовыми CRUD операциями
2. **AbstractCrudService** - абстрактный класс с общей реализацией
3. **EntityService** - конкретный сервис с дополнительными методами поиска
4. **EntityBusinessService** - бизнес-сервис с бизнес-логикой и событиями

### Вопрос 3: Как обрабатывать транзакции?
**Ответ**: 
- Используйте `@Transactional` на уровне сервисов
- Размещайте аннотацию на публичных методах
- Используйте `@Transactional(readOnly = true)` для методов чтения
- Избегайте транзакций в контроллерах

### Вопрос 4: Как правильно валидировать данные?
**Ответ**:
- Используйте Bean Validation для простой валидации
- Создавайте отдельные валидаторы для сложной бизнес-логики
- Валидируйте данные на уровне DTO
- Проверяйте бизнес-правила в сервисах

## Контрольный список

Перед созданием контроллера/сервиса убедитесь, что:

- [ ] Определена правильная иерархия сервисов (CrudService → AbstractCrudService → EntityService → EntityBusinessService)
- [ ] Контроллер не содержит бизнес-логики
- [ ] Все DTO имеют валидацию и используют @JiltBuilder
- [ ] Созданы правильные исключения для разных типов ошибок
- [ ] Настроена глобальная обработка исключений
- [ ] Добавлено структурированное логирование
- [ ] Написаны unit и интеграционные тесты
- [ ] Добавлена JavaDoc для публичных методов
- [ ] Проверена производительность запросов
- [ ] Учтены вопросы безопасности

## Дополнительные ресурсы

- [Spring Boot Documentation](https://spring.io/projects/spring-boot)
- [Spring Data JPA Reference](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/)
- [Bean Validation Specification](https://beanvalidation.org/)
- [Clean Architecture by Robert C. Martin](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)
- [SOLID Principles](https://en.wikipedia.org/wiki/SOLID) 